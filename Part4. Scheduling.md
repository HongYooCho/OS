### Scheduling
* CPU Scheduling: 어떤 프로세스를 씨피유에 할당시킬지 결정하는 작업
* 디스패쳐: 스케쥴러안에 있는 모듈로써 스케쥴러에게 선택된 프로세스에게 CPU 통제권을 주는 것
* Dispatch latency: 하나의 프로세스를 중단 시키고 다른 프로세스를 실행시키는 시간
### CPU & I/O burst
CPU나 I/O 둘중 하나에 더 버스트 하는 시간 (연산이냐 아이오 작업이냐의 차이)
### 스케쥴링의 기준
* CPU utilization: CPU를 가능한 바쁘게 만들자
* Throughput: 단위 시간당 끝나는 프로세스의 수(얼마나 많은 양의 작업을 끝낼수 있는가)
* Turnaround time: 특정 프로세스를 실행시키는 시간 – 한 프로세스가 끝나고 다른 프로세스를 실행시키는 데 걸리는 시간
* Waiting time: 레디큐에서 기다리는 시간
* Response time: 요청이 오고 첫 응답을 내는 데까지 걸리는 시간
#### Process and State Transition
CPU 스케쥴링 결정은 러닝상태에서 웨이팅 상태로 바뀔 때, 러닝에서 레디, 웨이팅에서 레디, 종료일때 발생한다. 
#### Non-preemptive vs Preemptive
* 선점형식인가 비선점인가, 인터럽트를 통해서 프로세스를 바꿀수 있는가 없는가의 차이
* 비선점: CPU가 프로세스를 다 끝내고 나서야 다른 프로세스를 받는다.(적은 컨텍스트 스위치, 응답시간이 매우 느림)
* 선점: CPU에 인터럽트가 들어온다면 다른 프로세스로 바꿀 수 있다. (응답시간은 매우빠름, 컨텍스트 스위치가 많이 일어남)

### FCFS
* 빨리온대로 빨리 처리 -> 걍 큐를 사용해서 집어 넣자 비선점 스케쥴링
* 컨보이 이펙트: I/O 바운드 프로세스에서 오랜 웨이팅 타임
* 오랜시간이 걸리는 프로세스를 앞으로 땡기면 그만큼 뒤에 있는 프로세스들의 대기시간이 길어짐, CPU와 디바이스 효율성이 떨어짐
### SJF 스케쥴링
짧은 프로세스들부터 줄세워서 끝내자 -> 선점식과 비선점식이 존재
* 선점식 SJF: 얜 걍 들어오는 것들 중 가장 짧은거
* 비선점식 SJF: 들어오는 프로세스들과 현재 돌아가는 프로세스의 남은 시간까지 비교하여 젤 짧은 거 선택해서 돌리기
가장 작은 웨이팅 평균시간이 걸리고, 레디큐에 있는 프로세스들의 수를 줄일 수 있으며, 빠른 응답을 보일수 있다.
<br>하지만, 스타베이션이 발생 -> 일처리가 오래걸리는 놈은 계속 뒤로 가므로 Cpu를 할당 받지 못하고 굶음<br>
스타베이션을 막기위해서 priority를 두어 짧은 시간을 가진 프로세스들만 돌리지 않게 한다. (aging)
### RoundRobin
시간 간격을 두어 계속해서 프로세스를 바꾸는 것, 시간 간격(1quantum)에 한 인터럽트 컨텍스트 스위치
<br>응답률과 한 프로세스의 CPU 독점현상을 막을 수 있으나 너무 많은 컨텍스트 스위치가 문제
### Multiple Processor 스케쥴링
* CPU가 하나인 경우보다 더 복잡한 상황: 어떤 CPU에서 프로세스를 줄까?
* CPU들 사이에서 프로세스들을 옮기는 것은 코스트가 많이 든다. (많은 캐시미스들)
* Affinity Scheduling: 같은 CPU에 같은 프로세스들로 하자
* Load balancing: 일거리들을 골고루 분배 하나의 CPU에만 몰빵하지말자
* Migration: 놀고 있는 프로세서들에게 바쁜 프로세서들의 일을 넘겨주자
### Rate monotonic scheduling
각 프로세스는 기간 마다 들어오게 된다. 데드라인은 다음 프로세스가 들어오기 전까지 일을 마무리 지어야한다.
<br>그림에서 50에서 P1이 들어왔으므로 priority에 의해 컨텍스트 스위치 그리고 P1이 돌고 나머지 P2연산을 수행.
<br> 즉 주기가 돌아오기전까지 프로세스의 일을 모두 마무리 해야한다.
<br>하지만 이런식으로 할 경우 데드라인 전까지 일을 못마치는 프로세스들이 발생할 수 있다.
### EDF(Earliest Deadline First Scheduling)
우선순위를 단순히 버스트가 짧은거에 더 높은 것을 두는 것이 아닌 일찍 끝날수록 높은 우선순위를 주게한다. <br>즉 남아있는 프로세스의 양과 들어오는 프로세스 양을 비교하여 짧은 것을 선택해 돌리게하자

## FCFS, RR, priority
* FCFS: https://github.com/yooyj9309/OS-scheduling-fcfs-
* RR: https://github.com/yooyj9309/OS-scheduling-RR-
* Pritority: https://github.com/yooyj9309/OS-scheduling-Priority-
