### Deadlock
### Dining Philosophers
<br>N명의 철학자가 N개의 포크로 밥을 먹는다 근데 두개의 포크가 있어야 밥을 먹는다.
<br>근데 N명의 철학자가 왼쪽 포크를 다집으면 오른쪽에 포크가 없다. 그래서 다 밥못 먹음
<br>왜냐면 다 오른쪽의 포크를 기다리고는 있는데 내려놓지를 않아서
* Waiting state: 프로세스가 자원과 행동을 기다리는 상태, 요청했는데 다른 놈이 쓰고 있어서 못쓰는 상태
* Deadlock state: 절대 일어날 수 없는 일을 기다리고 있는 특별한 상태
<br>기다리고 있는 프로세스가 상태를 변화할수 없을 때, 왜냐면 그 프로세스가 자원을 가지고 있으면서 기다리고 있으니까 내놓지도 못하고 끝내지도 못하고 문제

### System model
시스템은 유한한 자원으로 구성되어있다.
* 물리적 자원: I/O 장치, 메모리 공간, CPU
* 논리적 자원: 세마포어, 뮤텍스 락, 파일
<br><br>Instance: 같은 종류의 자원의 수, 만약 한 시스템이 두개의 CPU를 가지고 있으면 두개의 인스턴스가 존재
* 프로세스들은 인스턴스를 요구한다. 그 요청을 만족시킬 만큼 인스턴수를 제공
* 프로세스들은 리스소 인스턴스를 사용하기 전에 요구를 먼저 해야하고, 다썼으면 제자리에 반납하자

### Deadlock Characterization
데드락이 발생하게되는 이유 4가지 중요
1. ME: 하나의 프로세스만 하나의 자원에 접근할 수 있다.
2. Hold and wait: 하나 이상의 자원을 가지고 있으면서 또 다른 자원을 기다리고 있다.
3. No preemption: 프로세스가 완료되기 전까지 다른 프로세스가 선점할 수 없다.
4. Circular wait: 돌고 돌아 나한테까지 p0->p1-p0\
<br>또 여기서 중요한건 이 4가지 조건이 있다해서 무조건 데드락은 아님
<br>데드락이 있다면 이 4가지는 있지만, 이 4가지가 있다고 해서 데드락이라는 것은 아님\
<br>그 이유는 여러 개의 인스턴스가 존재하면 데드락이 안걸리는 경우가 존재

### Ostrich algorithm
솔직히 데드락이 자주 걸리는 것도 아니고 어쩌다가 한번인데 그냥 껏다 킨다.

### Deadlock을 다루는 방법 4가지
1> Deadlock Prevention: 위에 말했던 4가지 이유 중 하나 이상이 일어나지 않도록 막는다.<br>
1. ME: 모든 리소스를 공유 가능하게 하자 –사실상 불가능
2. Hold and wait: 프로세스가 자원을 요구할때마다 다른 자원을 홀드 하지 않는 것을 보장
	- 예 프로세스가 여러 자원을 필요로 할 때 한번에 할당해버리자.
	- 자원 효율성이 떨어지고 스타베이션이 걸림
	- 사용하지 않은 자원도 분명 있는데 가지고 만 있고 다른놈들 못쓰게 하기 때문에
3. No preemption: 기본적으로 말이 안됨-> 스케쥴링 하지말라는 소리
;4. Circular Wait: 순서를 부여하여 자원에 접근하게 하자.
	- Dining Philosophers: 자원에 부여된 숫자가 낮은 것부터 집게 하자.
	- 그러면 한 사람은 두개의 포크를 들수 있으므로 야미 할 수 있음
<br>-> 자원 효율성도 낮고 시스템 쓰루풋도 낮고 높은 코스트가 든다.
2> Deadlock avoidance: 어떻게 자원들이 요청되는 지에 대한 정보가 필요하다.<br>
* 프로세스들은 필요한 최대의 자원 수를 선언한다.
* 필요한 리소스 타입: available, allocated, needed
* 이용가능한 자원의 수, 할당된 자원의수, 프로세스가 요구하는 자원의 수
* Safe sequence: 데드락없이 프로세스를 끝낼 수 있다는 것을 명확히 아는 순서
* Unsafe한 상태라해서 무조건 데드락은 아니고, 데드락이면 무조건 Unsafe한 상태이다.

### Banker’s Algorithm
이 시스템이 safe state인지 아닌지 판단을 해준다.
* Allocation   Max  &nbsp;&nbsp; Available<br>
&nbsp;&nbsp;&nbsp;&nbsp;A B C  A B C  A B C<br>
P0   0 1 0   7 5 3   3 3 2<br>
P1   2 0 0   3 2 2 <br>
P2   3 0 2   9 0 2 <br>
P3   2 1 1   2 2 2 <br>
P4   0 0 2   4 3 3 <br>
* 위의 상황은 (A:10, B:5, C:7)?
1. 0은 7 4 3개가 필요
2. 1은 1 2 2개가 필요
3. 2는 6 0 0개가 필요
4. 3은 0 1 1개가 필요
5. 4는 4 3 1개가 필요
6. 0는 충족 시킬 수 없으므로 pass. 1의 경우 충족 가능
* -> 1의 자원들 모두 반환하고 available에 추가
* Available은 4 5 4개. 2는 충족 안됨. 3은 됨. 위의 행동 반복
* 계속 반복해서 리소스를 다 충족 시킬수 있으면 safe 안되면 unsafe

3> Deadlock Detection<br>
시스템을 데드락 상태에 들어가게 하는 것<br><br>
4> Deadlock Recovery
* 데드락을 감지한 후 회복하는 과정
1) 프로세스를 종료시킨다. 걍 껐다 키는 느낌<br>
2) 자원 선점을 한다. 데드락을 제거할 수 있는 자원을 선점<br>
